@NonCPS
def parseXml(String xmlContent) {
    def parsedXml = new XmlSlurper().parseText(xmlContent)
    // Se sacan las métricas directamente del elemento testsuites
    def testsuitesMetrics = [
        name: parsedXml.'@name'.text(),
        totalTests: parsedXml.'@tests'.text().toInteger(),
        totalFailures: parsedXml.'@failures'.text().toInteger(),
        totalErrors: parsedXml.'@errors'.text().toInteger(),
        totalTime: parsedXml.'@time'.text().toFloat()
    ]

    // Aquí por ahora asumimos que sólo hay un testsuite por testsuites, si hay más a futuro, se necesitará iterar
    def testsuiteMetrics = parsedXml.testsuite.collect {
        [
            name: it.'@name'.text(),
            tests: it.'@tests'.text().toInteger(),
            failures: it.'@failures'.text().toInteger(),
            errors: it.'@errors'.text().toInteger(),
            time: it.'@time'.text().toFloat(),
            skipped: it.'@skipped'.text().toInteger(),
            timestamp: it.'@timestamp'.text()
        ]
    }

     // Recopilación de las métricas de los testcase con relación a su testsuite
    def testcaseMetrics = [:] // Un mapa para agrupar los testcase por testsuite
    parsedXml.testsuite.each { ts ->
        def tsName = ts.'@name'.text()
        testcaseMetrics[tsName] = ts.testcase.collect { tc ->
            def tcMetrics = [
                name: tc.'@name'.text(),
                time: tc.'@time'.text().toFloat(),
                status: tc.'@status'.text(),
        ]
        
            // Control de campos adicionales basados en el estado
            switch (tc.'@status'.text()) {
                case 'PASSED':
                    tcMetrics['result'] = 'OK'
                    break
                case 'ERROR':
                    tcMetrics['errorType'] = tc.error.'@type'.text()
                    tcMetrics['errorMessage'] = tc.error.'@message'.text()
                    break
                case 'FAILED':
                    tcMetrics['failureType'] = tc.failure.'@type'.text()
                    tcMetrics['failureMessage'] = tc.failure.'@message'.text()
                    break
            }
            return tcMetrics
        }
    }
    return [testsuites: testsuitesMetrics, testsuite: testsuiteMetrics, testcase: testcaseMetrics]
}

pipeline {
    agent {
        kubernetes {
            defaultContainer 'jdk'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
    - name: jdk
      image: docker.io/eclipse-temurin:20.0.1_9-jdk
      command:
        - cat
      tty: true
      volumeMounts:
        - name: m2-cache
          mountPath: /root/.m2
    - name: podman
      image: quay.io/containers/podman:v4.5.1
      command:
        - cat
      tty: true
      securityContext:
        runAsUser: 0
        privileged: true
    - name: kubectl
      image: docker.io/bitnami/kubectl:1.27.3
      command:
        - cat
      tty: true
      securityContext:
        runAsUser: 0
        privileged: true
  volumes:
    - name: m2-cache
      hostPath:
        path: /data/m2-cache
        type: DirectoryOrCreate
    - name: shared-data
      hostPath:
        path: /path/to/shared/folder
        type: DirectoryOrCreate
'''
        }
    }

        stages {

        stage('Generate Hash') {
            steps {
               script {
                    
                }
            }
        }
    }
}

