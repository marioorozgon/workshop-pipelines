@NonCPS
def parseXml(String xmlContent) {
def parsedXml = new XmlSlurper().parseText(xmlContent)
// Se sacan las mÃ©tricas directamente del elemento testsuites
def testsuitesMetrics = [
name: parsedXml.'@name'.text(),
totalTests: parsedXml.'@tests'.text().toInteger(),
totalFailures: parsedXml.'@failures'.text().toInteger(),
totalErrors: parsedXml.'@errors'.text().toInteger(),
totalTime: parsedXml.'@time'.text().toFloat()
]
// Se sacan las mÃ©tricas directamente del elemento testsuite
    def testsuiteMetrics = parsedXml.testsuite.collect {
        [
            name: it.'@name'.text(),
            tests: it.'@tests'.text().toInteger(),
            failures: it.'@failures'.text().toInteger(),
            errors: it.'@errors'.text().toInteger(),
            time: it.'@time'.text().toFloat(),
            skipped: it.'@skipped'.text().toInteger(),
            timestamp: it.'@timestamp'.text()
        ]
    }
// RecopilaciÃ³n de las mÃ©tricas de los testcase con relaciÃ³n a su testsuite
    def testcaseMetrics = [:] // Un mapa para agrupar los testcase por testsuite
    parsedXml.testsuite.each { ts ->
        def tsName = ts.'@name'.text()
        testcaseMetrics[tsName] = ts.testcase.collect { tc ->
            def tcMetrics = [
                name: tc.'@name'.text(),
                time: tc.'@time'.text().toFloat(),
                status: tc.'@status'.text(),
        ]
        
            // Control de campos adicionales basados en el estado
            switch (tc.'@status'.text()) {
                case 'PASSED':
                    tcMetrics['result'] = 'OK'
                    break
                case 'ERROR':
                    tcMetrics['errorType'] = tc.error.'@type'.text()
                    tcMetrics['errorMessage'] = tc.error.'@message'.text()
                    break
                case 'FAILED':
                    tcMetrics['failureType'] = tc.failure.'@type'.text()
                    tcMetrics['failureMessage'] = tc.failure.'@message'.text()
                    break
            }
            return tcMetrics
        }
    }
    return [testsuites: testsuitesMetrics, testsuite: testsuiteMetrics, testcase: testcaseMetrics]
}

@NonCPS
def constructPrometheusMetrics(Map metrics, String hash) {
    def metricData = ''

    // MÃ©tricas de testsuites
    def testsuitesValue = (metrics.testsuites.totalFailures > 0 || metrics.testsuites.totalErrors > 0) ? 1 : 0
    metricData += "katalon_testsuites_info{name=\"${metrics.testsuites.name}\", tests=\"${metrics.testsuites.totalTests}\", failures=\"${metrics.testsuites.totalFailures}\", errors=\"${metrics.testsuites.totalErrors}\", time=\"${metrics.testsuites.totalTime}\", hash=\"${hash}\", timestamp_execute=\"${env.PIPELINE_TIMESTAMP}\"} ${testsuitesValue}\n"

    // MÃ©tricas de testsuite
    metrics.testsuite.each { ts ->
        def testsuiteValue = (ts.failures > 0 || ts.errors > 0) ? 1 : 0
        metricData += "katalon_testsuite_info{name=\"${ts.name}\",tests=\"${ts.tests}\",failures=\"${ts.failures}\",errors=\"${ts.errors}\",time=\"${ts.time}\",skipped=\"${ts.skipped}\",timestamp=\"${ts.timestamp}\", hash=\"${hash}\"} ${testsuiteValue}\n"
    }

    // MÃ©tricas de testcase con etiqueta de testsuite
    metrics.testsuite.each { ts ->
        def tsName = ts.name
        metrics.testcase[tsName]?.each { tc -> // testcase del testsuite actual
                def testcaseValue = (tc.status == 'PASSED') ? 0 : 1
                def testcaseMetric = "katalon_testcase_info{testsuite=\"${ts.name}\", name=\"${tc.name}\", time=\"${tc.time}\", status=\"${tc.status}\", hash=\"${hash}\""


                if (testcaseValue == 0) {
                    testcaseMetric += ", result=\"OK\"} ${testcaseValue}\n"
                } else {
                    String detailType = tc.status == 'ERROR' ? 'error' : 'failure'
                    testcaseMetric += ", ${detailType}_type=\"${tc[detailType + 'Type']}\", ${detailType}_message=\"${tc[detailType + 'Message'].replaceAll('"', '\\"')}\"} ${testcaseValue}\n"
                }

                metricData += testcaseMetric
            }
        }
    
    return metricData
}

@NonCPS
def generateCustomHash() {
    def jobName = env.JOB_NAME ?: 'UnknownJob'
    def buildNumber = env.BUILD_NUMBER ?: '0'
    def currentTime = System.currentTimeMillis().toString()

    def stringToHash = "${jobName}-${buildNumber}-${currentTime}"
    def hash = stringToHash.hashCode().toString()

    return hash
}

@NonCPS
def parseAndGenerateMetrics(def xmlFilesOutput) {
    //def xmlFileList = xmlFilesOutput.split('\\r?\\n')
    def prometheusData = """
        # HELP katalon_testsuites_info Test Suites Information
        # TYPE katalon_testsuites_info gauge
        # HELP katalon_testsuite_info Test Suite Information
        # TYPE katalon_testsuite_info gauge
        # HELP katalon_testcase_info Test Case Information
        # TYPE katalon_testcase_info gauge
        """

    xmlFilesOutput.each { filePath ->
        def katalonXmlContent = readFile(filePath)
        def metrics = parseXml(katalonXmlContent)

        echo "Metrics parsed for ${filePath}: ${metrics}"

        prometheusData += constructPrometheusMetrics(metrics, env.PIPELINE_HASH)
        echo "Processing file: ${filePath}"
    }

    return prometheusData
}

@NonCPS
def readDirectory() {
    def xmlDirectory = 'C:\\Jenkins\\workspace\\Katalon_GTI_PRE\\Reports\\20231115_090057\\GTI\\20231115_090058'
    echo "readDirectory directorio: ${xmlDirectory}"
    def xmlFilesOutput = findFiles(glob: '**/*.xml') 
    echo """${files[0].name} ${files[0].path} ${files[0].directory} ${files[0].length} ${files[0].lastModified}"""
    return xmlFilesOutput
}

    node () {
                println "Hola 1"
                stage ('PreparaciÃ³n') {
                    script {
                        env.PIPELINE_TIMESTAMP = new Date().format('yyyy-MM-dd HH:mm:ss')
                        println "Antes sh ${env.PIPELINE_TIMESTAMP}"
                        echo "${env.PIPELINE_TIMESTAMP}"
                    }
                }
                println "Hola 2"
                stage('Generate Hash') {
                    script {
                       env.PIPELINE_HASH = generateCustomHash()
                       //sh "echo ${env.PIPELINE_HASH}"
                    }
                }
                
                stage('Parse Katalon XML') {
                    println "Hola 3"
                    sh 'pwd'
                    sh 'ls -l /var/jenkins_home/workspace/seur'
                    sh 'ls -l /var/jenkins_home/workspace/seur/xml_reports'
                   // xmlFiles = sh(script: "ls /home/jenkins/agent/workspace/seur/xml_reports/*.xml", returnStdout: true).trim().split('\n')
                   // echo "Archivos XML encontrados: ${xmlFiles.join(', ')}"

                    /*echo "Directorio de trabajo actual:"
                    sh 'pwd'
                    echo "Listando el contenido del directorio de trabajo actual:"
                    sh 'ls -l'
                    echo "Listando el contenido de la ruta base de los archivos XML:"
                    sh 'ls -l /home/jenkins/agent/workspace/seur/xml_reports'
                    echo "Buscando archivos XML en el directorio de trabajo actual y subdirectorios:"
                    sh 'find . -name "*.xml"'*/

                        /*xmlDirectory = '/home/jenkins/agent/workspace/seur/xml_reports'
                        echo "Directorio: ${xmlDirectory}"

                        xmlFiles = findFiles(glob: "${xmlDirectory}/*JUnit_Report*.xml")
                         xmlFiles.each { file ->
                            echo "Procesando archivo: ${file}"
                            katalonXml = readFile(file.path)
                            parseXml(katalonXml)
                        }*/
                    
                }
        
    }