import groovy.util.XmlParser
// Se sacan los metodos de parseo fuera del pipeline 
def parseXml(String xmlContent) {
    def parsedXml = new XmlParser().parseText(xmlContent)

    def testsuitesMetrics = [
        name: parsedXml.attribute('name'),
        totalTests: parsedXml.attribute('tests').toString().toInteger(),
        totalFailures: parsedXml.attribute('failures').toString().toInteger(),
        totalErrors: parsedXml.attribute('errors').toString().toInteger(),
        totalTime: parsedXml.attribute('time').toString().toFloat()
    ]

    def testsuiteNodes = parsedXml.children().findAll { it.name() == 'testsuite' }
    def testsuiteMetrics = []
    def testcaseMetrics = [:]

    testsuiteNodes.each { tsNode ->
        def tsMetrics = [
            name: tsNode.attribute('name'),
            tests: tsNode.attribute('tests').toString().toInteger(),
            failures: tsNode.attribute('failures').toString().toInteger(),
            errors: tsNode.attribute('errors').toString().toInteger(),
            time: tsNode.attribute('time').toString().toFloat(),
            skipped: tsNode.attribute('skipped').toString().toInteger(),
            timestamp: tsNode.attribute('timestamp')
        ]
        testsuiteMetrics.add(tsMetrics)

        def tcMetricsList = tsNode.children().findAll { it.name() == 'testcase' }.collect { tcNode ->
            def tcMetrics = [
                name: tcNode.attribute('name'),
                time: tcNode.attribute('time').toString().toFloat(),
                status: tcNode.attribute('status')
            ]
            switch (tcNode.attribute('status')) {
                case 'PASSED':
                    tcMetrics['result'] = 'OK'
                    break
                case 'ERROR':
                    tcMetrics['errorType'] = tcNode.children().find { it.name() == 'error' }?.attribute('type')
                    tcMetrics['errorMessage'] = tcNode.children().find { it.name() == 'error' }?.attribute('message')
                    break
                case 'FAILED':
                    tcMetrics['failureType'] = tcNode.children().find { it.name() == 'failure' }?.attribute('type')
                    tcMetrics['failureMessage'] = tcNode.children().find { it.name() == 'failure' }?.attribute('message')
                    break
            }
            return tcMetrics
        }
        testcaseMetrics[tsMetrics.name] = tcMetricsList
    }

    return [testsuites: testsuitesMetrics, testsuite: testsuiteMetrics, testcase: testcaseMetrics]
}

//Metodo de preparación de datos para envío a prometheus
def constructPrometheusMetrics(Map metrics, String hash) {
    def metricData = ''

    // Métricas de testsuites
    def testsuitesValue = (metrics.testsuites.totalFailures > 0 || metrics.testsuites.totalErrors > 0) ? 1 : 0
    metricData += "katalon_testsuites_info{name=\"${metrics.testsuites.name}\", tests=\"${metrics.testsuites.totalTests}\", failures=\"${metrics.testsuites.totalFailures}\", errors=\"${metrics.testsuites.totalErrors}\", time=\"${metrics.testsuites.totalTime}\", hash=\"${hash}\", timestamp_execute=\"${env.PIPELINE_TIMESTAMP}\"} ${testsuitesValue}\n"

    // Métricas de testsuite
    metrics.testsuite.each { ts ->
        def testsuiteValue = (ts.failures > 0 || ts.errors > 0) ? 1 : 0
        metricData += "katalon_testsuite_info{name=\"${ts.name}\",tests=\"${ts.tests}\",failures=\"${ts.failures}\",errors=\"${ts.errors}\",time=\"${ts.time}\",skipped=\"${ts.skipped}\",timestamp=\"${ts.timestamp}\", hash=\"${hash}\"} ${testsuiteValue}\n"
    }

    // Métricas de testcase con etiqueta de testsuite
    metrics.testsuite.each { ts ->
        def tsName = ts.name
        metrics.testcase[tsName]?.each { tc -> // testcase del testsuite actual
                def testcaseValue = (tc.status == 'PASSED') ? 0 : 1
                def testcaseMetric = "katalon_testcase_info{testsuite=\"${ts.name}\", name=\"${tc.name}\", time=\"${tc.time}\", status=\"${tc.status}\", hash=\"${hash}\""


                if (testcaseValue == 0) {
                    testcaseMetric += ", result=\"OK\"} ${testcaseValue}\n"
                } else {
                    String detailType = tc.status == 'ERROR' ? 'error' : 'failure'
                    testcaseMetric += ", ${detailType}_type=\"${tc[detailType + 'Type']}\", ${detailType}_message=\"${tc[detailType + 'Message'].replaceAll('"', '\\"')}\"} ${testcaseValue}\n"
                }

                metricData += testcaseMetric
            }
        }
    
    return metricData
}

def generateCustomHash() {
    def jobName = env.JOB_NAME ?: 'UnknownJob'
    def buildNumber = env.BUILD_NUMBER ?: '0'
    def currentTime = System.currentTimeMillis().toString()

    def stringToHash = "${jobName}-${buildNumber}-${currentTime}"
    def hash = stringToHash.hashCode().toString()

    return hash
}
