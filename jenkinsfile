// Sacamos los metodos de parseo fuera del pipeline 
//TODO ver si se puede pasar a una propia clase groovy

def parseXml(String xmlContent) {
    def parsedXml = new XmlSlurper().parseText(xmlContent)
    // Sacamos las métricas directamente del elemento testsuites
    def testsuitesMetrics = [
        name: parsedXml.'@name'.text(),
        totalTests: parsedXml.'@tests'.text().toInteger(),
        totalFailures: parsedXml.'@failures'.text().toInteger(),
        totalErrors: parsedXml.'@errors'.text().toInteger(),
        totalTime: parsedXml.'@time'.text().toFloat()
    ]
    // Aquí asumimos que sólo hay un testsuite por testsuites, si hay más, necesitarás iterar
    def testsuiteMetrics = parsedXml.testsuite.collect {
        [
            name: it.'@name'.text(),
            tests: it.'@tests'.text().toInteger(),
            failures: it.'@failures'.text().toInteger(),
            errors: it.'@errors'.text().toInteger(),
            time: it.'@time'.text().toFloat(),
            skipped: it.'@skipped'.text().toInteger(),
            timestamp: it.'@timestamp'.text()
        ]
    }

    // Recopilación de métricas de los testcase
    def testcaseMetrics = parsedXml.testsuite.testcase.collect { tc ->
        def tcMetrics = [
            name: tc.'@name'.text(),
            time: tc.'@time'.text().toFloat(),
            status: tc.'@status'.text()
        ]
        
        // Añadir campos adicionales basados en el estado
        switch (tc.'@status'.text()) {
            case 'PASSED':
                tcMetrics['result'] = 'OK'
                break
            case 'ERROR':
                tcMetrics['errorType'] = tc.error.'@type'.text()
                tcMetrics['errorMessage'] = tc.error.'@message'.text()
                break
            case 'FAILED':
                tcMetrics['failureType'] = tc.failure.'@type'.text()
                tcMetrics['failureMessage'] = tc.failure.'@message'.text()
                break
        }
        
        return tcMetrics
    }
    // Retorna ambos, testsuitesMetrics y testsuiteMetrics
    return [testsuites: testsuitesMetrics, testsuite: testsuiteMetrics, testcase: testcaseMetrics]
}

def constructPrometheusData(Map metrics) {
    // Inicia la cadena de texto de Prometheus
    def prometheusData = """
# HELP katalon_testsuites_info Test Suites Information
# TYPE katalon_testsuites_info gauge
katalon_testsuites_info{name="${metrics.testsuites.name}",tests="${metrics.testsuites.totalTests}",failures="${metrics.testsuites.totalFailures}",errors="${metrics.testsuites.totalErrors}",time="${metrics.testsuites.totalTime}"} 1
"""

    // Agrega la métrica para testsuite, sin hostname e id
    metrics.testsuite.each { ts ->
        prometheusData += """
# HELP katalon_testsuite_info Test Suite Information
# TYPE katalon_testsuite_info gauge
katalon_testsuite_info{name="${ts.name}",tests="${ts.tests}",failures="${ts.failures}",errors="${ts.errors}",time="${ts.time}",skipped="${ts.skipped}",timestamp="${ts.timestamp}"} 1
"""
    }

    // HELP y TYPE para testcase solo una vez
    prometheusData += """
# HELP katalon_testcase_info Test Case Information
# TYPE katalon_testcase_info gauge
"""
    
    // Agrega la métrica para cada testcase sin repetir HELP y TYPE
    metrics.testcase.each { tc ->
        prometheusData += "katalon_testcase_info{name=\"${tc.name}\",time=\"${tc.time}\",status=\"${tc.status}\""
        if (tc.status == 'PASSED') {
            prometheusData += ",result=\"OK\"} 1\n"
        } else {
            // Agregamos detalles del error o fallo si el estado es ERROR o FAILED
            String detailType = tc.status == 'ERROR' ? 'error' : 'failure'
            prometheusData += ",${detailType}_type=\"${tc[detailType + 'Type']}\"" + 
                  ",${detailType}_message=\"${tc[detailType + 'Message'].replaceAll('"', '\\"')}\"} 0\n"
        }
    }

    return prometheusData
}

pipeline {
    agent {
        kubernetes {
            defaultContainer 'jdk'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
    - name: jdk
      image: docker.io/eclipse-temurin:20.0.1_9-jdk
      command:
        - cat
      tty: true
      volumeMounts:
        - name: m2-cache
          mountPath: /root/.m2
    - name: podman
      image: quay.io/containers/podman:v4.5.1
      command:
        - cat
      tty: true
      securityContext:
        runAsUser: 0
        privileged: true
    - name: kubectl
      image: docker.io/bitnami/kubectl:1.27.3
      command:
        - cat
      tty: true
      securityContext:
        runAsUser: 0
        privileged: true
  volumes:
    - name: m2-cache
      hostPath:
        path: /data/m2-cache
        type: DirectoryOrCreate
    - name: shared-data
      hostPath:
        path: /path/to/shared/folder
        type: DirectoryOrCreate
'''
        }
    }

    environment {
          PUSHGATEWAY_URL = 'http://localhost:9091' 
    }

    stages {
       
        stage('Parse Katalon XML') {
            steps {
                script {
                    // katalon.xml está en el directorio actual
                    def katalonXml = readFile('JUnit_Report_WebRec_Error.xml')

                    // parseXml para parsear el XML
                    def metrics = parseXml(katalonXml)

                    // Imprimir los resultados en la consola
                    echo "Metrics parsed: ${metrics}"

                    // Construye la cadena de datos para Prometheus con las métricas
                    def prometheusData = constructPrometheusData(metrics)

                    // Escribe las métricas en un archivo
                    writeFile(file: 'katalon.prom', text: prometheusData)

                    // imprimimos el contenido de 'prometheusData'
                    echo "Prometheus data:\n${prometheusData}"
                }
            }
        }

        stage('Send to Prometheus') {
              steps {
                  script {
                      
                      def prometheusData = readFile('katalon.prom').trim()
                      if (prometheusData) {
                        //def pushgatewayHost = '127.0.0.1'
                        //def pushgatewayPort = '9091' 
                        def pushgatewayUrl = "http://pushgateway-prometheus-pushgateway.default.svc.cluster.local:9091/metrics/job/katalon"
                        def response = sh(script: "curl -X POST --data-binary @katalon.prom ${pushgatewayUrl}", returnStdout: true).trim()
                        echo "Response from Pushgateway: ${response}"
                      } else {
                          error("Prometheus data está vacío, no envía al Pushgateway")
                      }
                  }
              }
          }
    }
}